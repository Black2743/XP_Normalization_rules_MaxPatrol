<13>Nov 28 09:05:01 {"name":"E19-01"} LOGSTASH[-]: 2024-11-28T09:05:01.329Z {name=E19-01} Создание текста Scriptblock (1 из 3):\n#load hashtable of localized string\nImport-LocalizedData -BindingVariable ConnectFunctions_LocalizedStrings -FileName ConnectFunctions.strings.psd1\n\n## Default and minimum timeout value for sessions  = 3 minutes\n## Maximum timeout value for sessions              = 15 minutes\n##\n$sessionOptionsTimeout = 180000;\nif (($env:MsExchEmsTimeout -ne $null) -and ($env:MsExchEmsTimeout -gt 180000) -and ($env:MsExchEmsTimeout -lt 900001))\n{\n    $sessionOptionsTimeout = $env:MsExchEmsTimeout;\n}\n##\n\n# help file specific for the function Connect-ExchangeServer.\n# can be viewed by running: get-help Connect-ExchangeServer\nfunction Connect-ExchangeServer ($ServerFqdn, [switch]$Auto, [switch]$Prompt, $UserName, $Forest,[switch]$ClearCache, $ClientApplication=$null, [switch]$AllowClobber)\n{\n#.EXTERNALHELP Connect-ExchangeServer-help.xml\n	set-variable VerbosePreference -value Continue\n	:connectScope do\n	{\n		if (!$Auto -and ($ServerFqdn -eq $null) -and !$Prompt)\n		{\n			_PrintUsageAndQuit\n		}\n\n		$useWIA = $true\n		if (!($userName -eq $null))\n		{\n		    $credential = get-credential $username\n		    $useWIA = $false\n		}\n\n\n		if (!($ServerFqdn -eq $null))\n		{\n			if ($Auto -or !($Forest -eq $null)) { _PrintUsageAndQuit }\n\n			_OpenExchangeRunspace $ServerFqdn $credential $useWIA -ClientApplication:$ClientApplication\n		}\n\n		if ($Auto)\n		{\n			# We should provide the $credential before $Forest, and we cannot assume useWIA $true here. It should be read from $useWIA\n			_AutoDiscoverAndConnect $credential $Forest -useWIA:$useWIA -ClientApplication:$ClientApplication\n		}\n		else\n		{\n			if (!($Forest -eq $null)) { _PrintUsageAndQuit }\n		}\n\n		Write-Host $ConnectFunctions_LocalizedStrings.res_0000\n		$fqdn=read-host -prompt $ConnectFunctions_LocalizedStrings.res_0001\n		_OpenExchangeRunspace $fqdn $credential $useWIA -ClientApplication:$ClientApplication\n	}\n	while ($false) #connectScope\n	\n	if ($ClearCache)\n	{\n		if ($AllowClobber)\n		{\n			ImportPSSession -ClearCache:$true -AllowClobber\n		}\n		else\n		{\n			ImportPSSession -ClearCache:$true\n		}\n	}\n	else\n	{\n		if ($AllowClobber)\n		{\n			ImportPSSession -ClearCache:$false -AllowClobber\n		}\n		else\n		{\n			ImportPSSession -ClearCache:$false\n		}\n	}\n}\n\nfunction Discover-ExchangeServer ([System.Management.Automation.PSCredential] $Credential, \n									$Forest, \n									[bool]$UseWIA=$false, \n									[bool]$SuppressError=$false, \n									[Microsoft.Exchange.Data.ServerVersion]$CurrentVersion=$null,\n									$ClientApplication = "EMC",\n									$AllowRedirection=$true)\n{\n	set-variable VerbosePreference -value Continue\n	:connectScope do\n	{\n		_AutoDiscoverAndConnect $Credential $Forest $UseWIA $SuppressError $CurrentVersion $ClientApplication $AllowRedirection\n	}\n	while ($false) #connectScope\n\n	if (!($global:remoteSession -eq $null))\n	{\n		$global:remoteSession.ComputerName\n		remove-pssession $global:remoteSession\n	}\n	else\n	{\n		if ($SuppressError -and ($error.Count -ne 0))\n		{\n			# When we suppress the error message, we still want the last error\n			Write-Error $error[0]\n		}\n	}\n}\n\nfunction _AutoDiscoverAndConnect ([System.Management.Automation.PSCredential]$Credential, \n									$Forest, \n									[bool]$UseWIA=$false, \n									[bool]$SuppressError=$false, \n									[Microsoft.Exchange.Data.ServerVersion]$CurrentVersion=$null,\n									$ClientApplication=$null,\n									$AllowRedirection=$false)\n{\n	if ($Forest -eq $null)\n	{\n		$fqdn = _GetHostFqdn $CurrentVersion\n		if ($fqdn -ne $null)\n		{\n			_OpenExchangeRunspace $fqdn $credential $UseWIA $SuppressError $ClientApplication $AllowRedirection\n		}\n\n		$forestName = _GetLocalForest\n		$siteList   = _GetSites\n		# Find servers in sites and connect, assuming the default behavior (connect to current site, \n		# if failed then connect to adjacent sites, if failed then connect to any random site that has exchange server)\n		foreach ($siteDN in $SiteList)\n		{\n			# E14: 184676 - MSIT: Tools only installation cannot find a remote PowerShell endpoint\n			# when the Forest name of the current site is not available, then we need to pass null value for forest  \n			if (($siteDN -ne "*") -and ($forestName -ne $null))\n			{\n				$servers = _GetExchangeServersInSite $siteDN "/$forestName"\n			}\n			else\n			{\n				$servers = _GetExchangeServersInSite $siteDN \n			}\n			if (($siteDN -ne "*")-and ($servers -eq $null))\n			{\n				$siteName = $siteDN.ToString().SubString(3).Split(",")[0]\n				Write-Warning ($ConnectFunctions_LocalizedStrings.res_0002 -f $siteName)\n			}\n			if (($siteDN -eq "*")-and ($servers -eq $null))\n			{\n			        Write-Error $ConnectFunctions_LocalizedStrings.res_0003\n			}\n			_ConnectToAnyServer $servers $credential $UseWIA $SuppressError $CurrentVersion $ClientApplication $AllowRedirection\n		}\n	}\n	else\n	{\n		$servers = _GetExchangeServersInSite "*" "/$Forest"\n		_ConnectToAnyServer $servers $credential $UseWIA $SuppressError $CurrentVersion $ClientApplication $AllowRedirection\n	}\n}\nfunction _GetSites()\n{\n	$localSite=[System.DirectoryServices.ActiveDirectory.ActiveDirectorySite]::GetComputerSite()\n	if ($localSite -eq $null)\n	{\n		return #no site - no auto discovery\n	}\n	$siteDN=$localSite.GetDirectoryEntry().DistinguishedName\n	$siteList = New-Object System.Collections.ArrayList\n	if ($siteDN -ne $null)\n	{\n		[void] $SiteList.Add($siteDN)\n	}\n	# DCR 231555: TAp DCR:Respect site-link costs with remote powershell.\n	# Now go one level to find adjacent sites based on site link and add them in the site list\n	if ($localSite.SiteLinks -ne $null)\n	{\n		foreach ($siteLink in $localSite.SiteLinks)\n		{\n			$siteDN = $null\n			# block going backwords\n			if (($siteLink.Sites[0] -ne $null) -and ($siteLink.Sites[0].Name -ne $localSite.Name))\n			{\n				$siteDN = $siteLink.Sites[0].GetDirectoryEntry().DistinguishedName\n			}\n			elseif ($siteLink.Sites[1] -ne $null)\n			{\n				$siteDN = $siteLink.Sites[1].GetDirectoryEntry().DistinguishedName\n			}\n			if ($siteDN -ne $null)\n			{ \n				[void] $SiteList.Add($siteDN)\n			}\n		}\n	}\n	# When no exchange server will be found in the current site or adjacent sites, then we should search in all sites\n	[void] $SiteList.Add("*")\n	$siteList\n}	\n\nfunction _GetLocalForest()\n{\n	[System.DirectoryServices.ActiveDirectory.Domain]::GetComputerDomain().Forest.Name\n}	\n\nfunction _GetHostFqdn([Microsoft.Exchange.Data.ServerVersion]$CurrentVersion=$null)\n{\n	if (@(get-item HKLM:\SOFTWARE\Microsoft\ExchangeServer\v15\*role -erroraction:silentlycontinue).length -gt 0)\n	{\n		$setupRegistryEntry = get-itemproperty HKLM:\SOFTWARE\Microsoft\ExchangeServer\v15\Setup -erroraction:silentlycontinue\n		if ($CurrentVersion -ne $null -and $setupRegistryEntry -ne $null -and\n			($CurrentVersion.Major -ne $setupRegistryEntry.MsiProductMajor -or\n			$CurrentVersion.Minor -ne $setupRegistryEntry.MsiProductMinor -or\n			$CurrentVersion.Build -ne $setupRegistryEntry.MsiBuildMajor -or\n			$CurrentVersion.Revision -ne $setupRegistryEntry.MsiBuildMinor))\n		{\n			return $null\n		}\n		try\n		{\n			return [System.Net.Dns]::GetHostByName("LocalHost").HostName\n		}\n		catch\n		{\n			Write-Verbose $ConnectFunctions_LocalizedStrings.res_0004\n			return $null\n		}\n	}\n	else\n	{\n		return $null\n	}\n}\n\nfunction _GetServerFqdnFromNetworkAddress($server)\n{\n   $server.properties["networkaddress"] |\n      where {$_.ToString().StartsWith("ncacn_ip_tcp")} | %{$_.ToString().SubString(13)}\n}\n\n\nfunction _GetExchangeServersInSite($siteDN, $Forest=$null)\n{\n	$configNC=([ADSI]"LDAP:/$Forest/RootDse").configurationNamingContext\n	$search = new-object DirectoryServices.DirectorySearcher([ADSI]"LDAP:/$Forest/$configNC")\n	$search.Filter = "(&(objectClass=msExchExchangeServer)(versionNumber>=1937801568)(msExchServerSite=$siteDN))"\n	$search.PageSize=1000\n	$search.PropertiesToLoad.Clear()\n	[void] $search.PropertiesToLoad.Add("msexchcurrentserverroles")\n	[void] $search.PropertiesToLoad.Add("networkaddress")\n	[void] $search.PropertiesToLoad.Add("serialnumber")\n	$search.FindAll()\n}\n\nfunction _GetCurrentVersionServers($servers, [Microsoft.Exchange.Data.ServerVersion]$CurrentVersion)\n{\n	$sameVersionServers=@()\n	$sameBuildServers=@()\n	$sameProductMajorMinorServers=@()\n	foreach ($server in $servers)\n	{\n		[Microsoft.Exchange.Data.ServerVersion]$version=$null\n		if([Microsoft.Exchange.Data.ServerVersion]::TryParseFromSerialNumber($server.Properties["serialnumber"][0], [ref]$version))\n		{\n			if($version -ne $null)\n			{\n				if ($version.Equals($CurrentVersion))\n				{\n					$sameVersionServers += $server\n				}\n				elseif (($version.Major -eq $CurrentVersion.Major) -and ($version.Minor -eq $CurrentVersion.Minor) -and ($version.Build -eq $CurrentVersion.Build))\n				{\n					$sameBuildServers += $server\n				}\n			}\n		}\n	}\n	return @($sameVersionServers + $sameBuildServers)\n}\n\nfunction _GetWebServiceServers($servers, [Microsoft.Exchange.Data.ServerVersion]$CurrentVersion=$null)\n{\n	$allFfoWs = $servers | where {(($_.properties["msexchcurrentserverroles"][0] -band 65536) -and ($_.path -like "*/CN=*[WM][SF]0*"))}\n	if ($allFfoWs -eq $null)\n	{\n		return @()\n	}\n\n	$webServiceServers = @()\n	if ($CurrentVersion -eq $null)\n	{\n		$webServiceServers = $allFfoWs\n	}\n	else\n	{\n		$webServiceServers = @(_GetCurrentVersionServers $allFfoWs $CurrentVersion)\n	}\n    \n    return $webServiceServers;	\n}\n\nfunction _GetCASServers($servers, [Microsoft.Exchange.Data.ServerVersion]$CurrentVersion=$null)\n{\n	$allCas = $servers | where {($_.properties["msexchcurrentserverroles"][0] -band 4)}\n	if ($allCas -eq $null)\n	{\n		return @()\n	}\n	if ($CurrentVersion -eq $null)\n	{\n		return $allCas\n	}\n	else\n	{\n		return @(_GetCurrentVersionServers $allCas $CurrentVersion)\n	}\n}\n\nfunction _GetCAFEServers($servers, [Microsoft.Exchange.Data.ServerVersion]$CurrentVersion=$null)\n{\n	$allCafes = $servers | where {($_.properties["msexchcurrentserverroles"][0] -band 1)}\n	if ($allCafes -eq $null)\n	{\n		return @()\n	}\n	if ($CurrentVersion -eq $null)\n	{\n		return $allCafes\n	}\n	else\n	{\n		return @(_GetCurrentVersionServers $allCafes $CurrentVersion)\n	}\n}\n\n# This function returns all non-cas and non-cafe servers, that includes mailbox, hub transport and um servers only\nfunction _GetHubMailboxUMServers($servers, [Microsoft.Exchange.Data.ServerVersion]$CurrentVersion=$null)\n{\n	$allNonCasCafe = $servers | where {(($_.properties["msexchcurrentserverroles"][0] -band 4) -eq 0) -and (($_.properties["msexchcurrentserverroles"][0] -band 1) -eq 0) -and\n					($_.properties["msexchcurrentserverroles"][0] -band 50)}\n	if ($allNonCasCafe -eq $null)\n	{\n		return @()\n	}\n	if ($CurrentVersion -eq $null)\n	{\n		return $allNonCasCafe\n	}\n	else\n	{\n		return @(_GetCurrentVersionServers $allNonCasCafe $CurrentVersion)\n	}\n}\n\nfunction _NewExchangeRunspace(\n				[String]$fqdn, \n				[System.Management.Automation.PSCredential] $credential=$null, \n				[bool]$UseWIA=$true, \n				[bool]$SuppressError=$false,\n				$ClientApplication=$null,\n				$AllowRedirection=$false,\n				[String]$targetServerUriParameter=$null)\n{\n	$hostFQDN = _GetHostFqdn\n	if (($fqdn -ne $null) -and ($hostFQDN -ne $null) -and ($hostFQDN.ToLower() -eq $fqdn.ToLower()))\n	{\n	    $ServicesRunning = _CheckServicesStarted\n	    if ($ServicesRunning -eq $false)\n	    {\n	        return\n	    }\n	}\n	Write-Verbose ($ConnectFunctions_LocalizedStrings.res_0005 -f $fqdn)\n	$so = New-PSSessionOption -OperationTimeout $sessionOptionsTimeout -IdleTimeout $sessionOptionsTimeout -OpenTimeout $sessionOptionsTimeout;\n	$setupRegistryEntry = get-itemproperty HKLM:\SOFTWARE\Microsoft\ExchangeServer\v15\Setup -erroraction:silentlycontinue\n	if ( $setupRegistryEntry -ne $null)\n	{\n		$clientVersion = "{0}.{1}.{2}.{3}" -f $setupRegistryEntry.MsiProductMajor, $setupRegistryEntry.MsiProductMinor, $setupRegistryEntry.MsiBuildMajor, $setupRegistryEntry.MsiBuildMinor\n		$connectionUri = "http://$fqdn/powershell?serializationLevel=Full;ExchClientVer=$clientVersion"\n	}\n	else\n	{\n		$connectionUri = "http://$fqdn/powershell?serializationLevel=Full"\n	}\n	\n	if ($ClientApplication -ne $null)\n	{\n		$connectionUri = $connectionUri + ";clientApplication=$ClientApplication"\n	}\n\n	if ($targetServerUriParameter -ne $null)\n	{\n		$connectionUri = $connectionUri + ";TargetServer=$targetServerUriParameter"\n	}\n	\n	$contents = 'New-PSSession -ConnectionURI "$connectionUri" -ConfigurationName Microsoft.Exchange -SessionOption $so'\n	\n	if (-not $UseWIA)\n	{\n		$contents = $contents + ' -Authentication Kerberos -Credential $credential'\n	}\n	if ($SuppressError)\n	{\n		$contents = $contents + ' -erroraction silentlycontinue'\n	}\n	if ($AllowRedirection)\n	{\n		$contents = $contents + ' -AllowRedirection'\n	}\n	[ScriptBlock] $command = $executioncontext.InvokeCommand.NewScriptBlock([string]::join("`n", $contents))\n	$session=invoke-command -Scriptblock $command\n	\n  if (!$?)\n	{\n	  # ERROR_ACCESS_DENIED = 5\n	  # ERROR_LOGON_FAILURE = 1326\n	  if (!(5 -eq $error[0].exception.errorcode) -and\n		  !(1326 -eq $error[0].exception.errorcode))\n	  {\n			#Write-Verbose ($ConnectFunctions_LocalizedStrings.res_0006 -f $fqdn)\n			return\n	  }\n	  else\n	  {\n	    # no retries if we get 5 (access denied) or 1326 (logon failure)\n	    #$REVIEW$ connectedFqdn is not set. Is it okay?\n	    break connectScope\n	  }\n	}\n  $session\n}\n\nfunction _OpenExchangeRunspace([String]$fqdn, \n				[System.Management.Automation.PSCredential] $credential, \n				[bool]$UseWIA=$true, \n				[bool]$SuppressError=$false,\n				$ClientApplication=$null,\n				$AllowRedirection=$false)\n{\n  $global:remoteSession = _NewExchangeRunspace $fqdn $credential $UseWIA $SuppressError $ClientApplication $AllowRedirection\n\n  if ($global:remoteSession -ne $null)\n  {\n	  $global:connectedFqdn = $fqdn\n	  break connectScope\n  }\n}\n\nfunction CreateOrGetExchangeSession(\n			[String]$fqdn, \n			[System.Management.Automation.PSCredential] $credential=$null, \n			[bool]$UseWIA=$true, \n			[bool]$SuppressError=$false,\n			[String]$targetServerUriParameter=$null)\n{\n   $existingSession = @(Get-PSSession | Where {$_.ComputerName -eq $fqdn -and $_.Availability -eq 'Available' -and $_.ConfigurationName -eq 'Microsoft.Exchange'})\n\n   if (($existingSession.Count -gt 0) -and ($targetServerUriParameter -eq $null))\n   {\n    if ($existingSession.Count -gt 1)\n    {\n      Write-Warning ($ConnectFunctions_LocalizedStrings.res_0007 -f $fqdn)\n    }\n    Write-Verbose ($ConnectFunctions_LocalizedStrings.res_0008 -f $fqdn)\n    return $existingSession[0]\n   }\n   else\n   {\n    Write-Verbose ($ConnectFunctions_LocalizedStrings.res_0009 -f $fqdn)\n    _NewExchangeRunspace $fqdn $credential $UseWIA $SuppressError $null $false $targetServerUriParameter\n   }\n}\n\nfunction _ConnectToAnyServer ($servers, \n				$credential, \n				[bool]$UseWIA=$false, \n				[bool]$SuppressError=$false, \n				[Microsoft.Exchange.Data.ServerVersion]$CurrentVersion=$null,\n				$ClientApplication=$null,\n				$AllowRedirection=$false)\n{\n	if (($servers -eq $null) -or ($servers.Length -eq 0))\n	{\n		return\n	}\n\n	$cafe=@(_GetCAFEServers $servers $CurrentVersion)\n\n	for($i=0;$i -lt $cafe.Length;$i++)\n	{\n		$fqdn = _GetServerFqdnFromNetworkAddress $cafe[($i+$start) % $cafe.Length]\n		_OpenExchangeRunspace $fqdn $credential $UseWIA $SuppressError $ClientApplication $AllowRedirection\n	}\n\n	$webServiceServers=@(_GetWebServiceServers $servers $CurrentVersion)\n\n	for($i=0;$i -lt $webServiceServers.Length;$i++)\n	{\n		$fqdn = _GetServerFqdnFromNetworkAddres\n\nИД ScriptBlock: 26f396e7-415f-4a31-bb70-867bab0fcba7\nПуть: C:\Program Files\Microsoft\Exchange Server\V15\bin\ConnectFunctions.ps1